\chapter{Type Systems}\label{cha:typesystems}

\coloredlettrine{F}{unction} definition in mathematics usually involves
specifying the~kind of inputs it accepts, and the~kind of output it produces.
For example, at the~start of the~previous chapter, we saw the~function $f(x) =
x + y$ applied to an~integer 0. Although we did not mention the~domain nor
the~range of the~function then, we can now pick some and say that $f$ is
a~function from integers to integers, or
\[
  f: \Int \to \Int.
\]
Corresponding to the~mathematical intuition, the~pure \lc can be modified by
attaching expressions called \emph{types} to terms, like labels to denote their
intended input and output. While conventionally the~term \emph{type} is used to
refer to an~abstraction of a~set of values, generally, a~type can be any
property of a~term, that we can establish without executing it.

We are looking to formulate the~procedure of assigning the~type annotations to
\lts, such that the~terms for which this procedure fails will be deemed
invalid. Hence, thanks to the~type system we are able to reject faulty programs
that exhibit unwanted behaviour before they are executed. As a~consequence of
the~\emph{Halting Problem} though, the~conclusions a~type system can make are
necessarily just approximations. Either it must reject programs that might have
run without an~error, or accept programs that may error when executed. With more
expressive type systems, we are able to more precisely decide whether to reject
a~given program.

In this chapter, we will formulate gradually more expressive type systems,
but to do that effectively, we need to introduce a~bit of new notation first.

\sectionwithtoc{Natural deduction}\label{sec:natural_deduction}

Conventionally, type systems are presented using \emph{natural deduction}, which
was first introduced by \citet{gentzen_1935} as a~new formulation of logic.
Natural deduction is a deductive system and is thus specified by a~collection of
\emph{judgments} and a~collection of \emph{rules}. A~rule takes a~list of
judgments and produces a~new judgment.

\emph{Judgment} is a~proposition in the~metalanguage. For example, in
first-order logic, judgment can say that a~certain string of symbols $A$ is
a~\emph{well-formed proposition}, written \emph{$A$ prop}. Another judgment may
say that these symbols form a~\emph{proposition that is true}, written
\emph{$A$ true}.

A~\emph{rule} is written as a~horizontal line with its \emph{premises}, or
\emph{antecedents}, above the~line and its \emph{conclusion}, or
\emph{consequent}, below the~line. There can be zero or more premises, but
conclusion is exactly one. The~interpretation of a~rule is that if all premises
hold, then the~conclusion follows. An~example of a~rule may be the~rule of
implication elimination, or \emph{modus ponens}, which can be stated as:
\begin{mathpar}
  \inferrule*[right=Mp]
  {P \supset Q \\ P}
  {Q}.
\end{mathpar}
It says that if ``$P$ implies $Q$,'' written $P \supset Q$, and ``$P$,'' then
``$Q$.'' Note that some rules have a~name, which is attached to the~right side
of the~horizontal line. In our example the~name is \ir{Mp}.

Given a~set of rules, we are able to combine them to form a~tree, where every
node is an~instance of a~rule. We say we can \emph{deduce}, or \emph{derive},
a~formula if there exists a~tree where the~formula is at the~root and all leaves
are \emph{axioms}, that is rules that have no premises.

Natural deduction also often involves \emph{hypothetical judgments}, or
\emph{reasoning from assumptions}. To express hypothetical reasoning within
the~rules of a~deductive system, we indicate in each judgment on which
hypotheses it depends. To denote the~hypothetical judgment of $Q$ assuming $P$,
we write
\[
  P \vdash Q.
\]
The~list of assumptions on which a~judgment depends, denoted by $\Gamma$, can be
extended by appending an~assumption $P$ to the~end of the~list with a~comma:
$\Gamma, P$. We can also combine lists of assumptions; the~list that results
from appending the~assumptions from $\Gamma_2$ to the~list $\Gamma_1$ is written
$\Gamma_1, \Gamma_2.$

For example, the~derivation tree of the~judgment that given that $P$ implies $Q$
and given $P$, one may deduce both $P$ and $Q$:
\begin{mathpar}
  \inferrule*
  {
    \inferrule*
    { }
    { P \supset Q, P \vdash P } \\
    \inferrule*[right=Mp]
    {
      \inferrule*
      { }
      {P \supset Q, P \vdash P \supset Q} \\
      \inferrule*
      { }
      {P \supset Q, P \vdash P }
    }
    { P \supset Q, P \vdash Q }
  }
  { P \supset Q, P \vdash P \wedge Q }.
\end{mathpar}

Notice that in the~definition of \ir{Mp} we have elided the~ambient
assumptions that could have been added to every judgment, i.e. we could have
written:
\begin{mathpar}
  \inferrule*[right=Mp$'$]
  {\Gamma_1 \vdash P \supset Q \\ \Gamma_2 \vdash P}
  {\Gamma_1, \Gamma_2 \vdash Q}.
\end{mathpar}

\sectionwithtoc{Simple types}

We will present a~few different type systems throughout the~text, each
an~extension of some previous ones. So to start at the~beginning, we will
define a~basic type system that utilises the~\emph{simple types}.

\begin{definition}\label{def:simple_type}
  Assume that we are given a finite or infinite sequence of symbols called
  \emph{atomic types}; then we define \emph{simple types} as follows:
  \begin{enumerate}
    \item every atomic type is a~simple type;
    \item if $S$ and $T$ are simple types, then $(S \to T)$ is a~simple type,
      called a~\emph{function type};
    \item if $S$ and $T$ are simple types, then $(S \times T)$ is a~simple type,
      called a~\emph{pair type};
  \end{enumerate}
\end{definition}

Atomic types are intended to denote a~particular set. For example we may have
the~atomic type \Int for the~set of integers, and \Bool for the~set of Boolean
values $\{ \mathtt{true}, \mathtt{false} \}$.

A~function type $(S \to T)$ is intended to denote some given set of
\emph{functions from $S$ to $T$}. That is, functions that accept as input
a~member of its \emph{domain}, the~set denoted by $S$, and produce an~output in
its \emph{range}, a~subset of the~set denoted by $T$. The~exact set of functions
denoted by $(S \to T)$ depends on the~intended use of the~type system we are
trying to build. It might be the~set of \emph{all} functions from $S$ to $T$, or
just some subset. Some examples of simple types are:
\begin{align*}
  &(\Int \to \Int) && \text{functions from integers to integers;} \\
  &(\Int \to \Bool) && \text{functions from integers to Boolean values;} \\
  &(\Int \to (\Int \to \Int)) && \text{functions from integers to functions;} \\
  &((\Int \to \Int) \to \Int) && \text{functions from functions to integers;} \\
  &((\Int \to \Int) \to (\Int \to \Int)) && \text{functions from functions to
    functions.}
\end{align*}
In contrast with the~\lt application, the~function type is right-associative
and we will abbreviate accordingly:
\begin{align*}
  &S \to T  &  &\text{for} &  &(S \to T); \\
  &S \to T \to U  &  &\text{for} &  &(S \to (T \to U)); \\
  &S_1 \to \dotsb \to S_n \to T  &  &\text{for} &
    &(S_2 \to ( \dotsb \to (S_n \to T) \dotsb )); \\
  &S \times T  &  &\text{for} &  &(S \times T).
\end{align*}
We do not define any order of precedence between the~function and pair types.
Note that an~expression like $S \to T$, which contains Greek-letter type
variables, is not itself a~type. It is only a~name in the~metalanguage for
a~type of unspecified functions.

A~pair type, or a~\emph{product type}, $(S \times T)$ denotes the~Cartesian
product of the~sets denoted by $S$ and $T$. For example, $((\Int \to \Int)
\times \Bool)$ denotes the~set of ordered pairs $(f, b)$, where $f$ is
a~function from integers to integers, and $b$ is a Boolean value.

There is also a~dual notion of a~pair type, the~\emph{sum type} $(S + T)$, which
is used to denote the~set of members of either $S$, or $T$. In this text
however, we are focused on the~pair type, so we will not be working with the~sum
type further.

\sectionwithtoc{Type judgment}

When we apply the~natural deduction in the~context of types, we are able to
formulate deduction trees that assign types to terms.

\begin{definition}
  For any \lt $M$ and type $T$, define a~\emph{type assignment} formula as
  \[
    M \is{} T.
  \]
\end{definition}

The~formula $M \is{} T$ can be read informally as ``$M$ has type $T$'', or ``we
assign to $M$ the~type $T$''. Then, \emph{type judgment} is the~formula
\[
  \Gamma \vdash M \is{} T,
\]
which is defined to mean that there is a~deduction-tree, whose root formula is
$M \is{} T$, and whose leaves are members of $\Gamma$. When type judgment has no
assumptions, we say so explicitly by writing
\[
  \vdash M \is{} T.
\]

\sectionwithtoc{Simply typed \lc}\label{sec:stlc}

Generally, there are two ways we can attach types to terms. The~\emph{implicit},
or \emph{Curry-style}, semantics use the~\lts as we have seen them in
\autoref{def:lambda_calculus} and assign type to a~term after it had been built.
The~type then sits next to the~term. In the~other approach, called
\emph{explicit}, or \emph{Church-style}, the~term's type is a~built-in part of
the~term itself.

We expect to present complex enough systems later, for which finding the types
in the~implicit version may not be computable~\citep{wells_1999}, hence we will
use the~explicit semantics.

\begin{definition}[Typed variables]
  Assume that we are given an~infinite sequence of expressions $\mathbf{v}_0,
  \mathbf{v}_1, \mathbf{v}_2, \dots$ called \emph{untyped variables}; then
  the~\emph{typed variable $x^T$} is an~untyped variable $x$ with attached
  type-superscript, such that:
  \begin{enumerate}
    \item \label{def:typed_var:a_item} no untyped variable receives more than
      one type;
    \item \label{def:typed_var:b_item} every type $T$ is attached to an~infinite
      sequence of variables.
  \end{enumerate}
\end{definition}
We call $x^T$ a~\emph{variable of type $T$}. It denotes an~arbitrary member of
the~set denoted by $T$.

Condition \ref{def:typed_var:a_item} ensures that there are no $x^T$, $x^S$ with
$T \not\equiv S$. For example, if we make a~typed variable $x^{\Int}$, to denote
an~arbitrary integer, we cannot also make $x^{\Int \to \Int}$, which would
denote a~function.

Condition \ref{def:typed_var:b_item} ensures that, for every type $T$, there
is always enough variables to denote all members of the~set that we wish to
describe.

\begin{definition}[Simply typed \lts]\label{def:stlc}
  The~set of \emph{typed \lts} is defined as follows:
  \begin{enumerate}
    \item all typed variables $x^T$ are typed \lts of type $T$;
    \item if $x^S$ is a~variable of type $S$ and $M^T$ is a~typed \lt of type
      $T$, then the~following is a~typed \lt of type $S \to T$:
      \[
        (\lam {x^S} {M^T})^{S \to T};
      \]
    \item \label{def:stlc:c_item} if $M^{S \to T}$ and $N^S$ are typed \lts
      of types $S \to T$ and $S$ respectively, then the~following is a~typed
      \lt of type $T$:
      \[
        (M^{S \to T} N^S)^T;
      \]
    \item \label{def:stlc:d_item} if $M^S$ and $N^T$ are typed \lts of types
      $S$ and $T$ respectively, then the~following is a~typed \lt of type
      $S \times T$:
      \[
        \mpair {M^S} {N^T} ^{S \times T};
      \]
    \setcounter{stlc_counter}{\value{enumi}}
    \item \label{def:stlc:e_item} if $x^S$ and $y^T$ are variables of types $S$
      and $T$ respectively, and $M^{S \times T}$ and $N^U$ are typed \lts of
      types $S \times T$ and $U$ respectively, then the~following is a~typed
      \lt of type $U$:
      \[
        (\textrm{let} \: \mpair {x^S} {y^T} = M^{S \times T} \:
        \textrm{in} \: N^{U})^U.
      \]
\end{enumerate}
\end{definition}

The~typed term $M^T$ is intended to denote a~member of the~set denoted by $T$.
For example, in \ref{def:stlc:c_item}, if $M^{S \to T}$ denotes a~function $f$
from $S$ to $T$, and $N^T$ denotes a~member $a$ of $S$, then the~term
$(M^{S \to T} N^S)^T$ denotes $f(a)$, which is of type $T$.

Note that in \ref{def:stlc:e_item}, the~pair $(x^S, y^T)$ is just a~part of
the~syntax; it is not an~instance of a~term constructing a~pair like in
\ref{def:stlc:d_item}.

When writing typed terms, some of the~type-superscripts can be omitted if it is
obvious from the~context what they should be. Other notation conventions will be
the~same as in \autoref{cha:lambdacalculus}.

For example, for every pair of types $S$ and $T$,
\[
  (\lam {x^S} {(\lam {y^T} {\mpair {x^S} {y^T} ^{S \times
    T}})^{T \to (S \times T)}})^{S \to (T \to (S
    \times T))}
\]
is a~typed term and it can be written as
\begin{align*}
  &(\lam {xy} {\mpair x y})^{S \to (T \to (S \times T))},  &
  &\text{or}  &  &\lam {x^S y^T} {\mpair x y}.
\end{align*}

The~substitution $[N^S/x^S](M^T)$ is defined in the~same way as the~substitution
of pure \lts in \autoref{def:substitution}. Note that we do not define
substitution $[N^U/x^S](M^T)$ when  $U \not\equiv S$. \todo{[NEEDS REWRITE TO
MENTION PAIRS]}

Finally, we will use the~simply typed \lc to construct a~formal theory where
the~deduction assigns types to terms. This is called a~\emph{type-assignment
system}. A~system with simply typed \lts usually has the~following rules:
\begin{mathpar}
  \inferrule*[right=Var]
  { }
  {\Gamma_1, x \is{} T, \Gamma_2 \vdash x \is{} T} \\

  \inferrule*[right=App]
  {\Gamma \vdash M \is{} S \to T \\ \Gamma \vdash N \is{} S}
  {\Gamma \vdash M \: N \is{} T}

  \inferrule*[right=Lam]
  {\Gamma, x \is{} S \vdash M \is{} T}
  {\Gamma \vdash \lam {x^S} M \is{} S \to T}

  \inferrule*[right=Let]
  {
    \Gamma \vdash M \is{} S \times T \\
    \Gamma, x \is{} S, y \is{} T \vdash N \is{} S
  }
  {
    \Gamma \vdash \textrm{let} \: \mpair {x^S} {y^T} = M \: \textrm{in}
    \: N \is{} U
  }

  \inferrule*[right=Pair]
  {\Gamma \vdash M \is{} S \\ \Gamma \vdash N \is{} T}
  {\Gamma \vdash \mpair M N \is{} S \times T}.
\end{mathpar}

\sectionwithtoc{Dependent types}

The Church-style system from the~previous chapter has lost some of
the~versatility of the~pure \lc. The~term $\lam {x^T} {x^T}$ represents
the~one operation of doing nothing, the~identity function, yet for different
types $T$ this one operation is represented by distinct terms. We want our
formalism to keep track of the~fact that identity does the~same thing regardless
of the~type. An~ability to universally quantify the~types, which we will gain
with the~introduction of dependent types, will allow us to express this; then
the~type of an~identity function will, in effect, be ``for all types $T$,\,
$T \to T$.''

To properly talk about dependent types, we feel we need to first touch on one
important observation; it is the~correspondence between computer programs and
mathematical proofs, known as the~\emph{Curry–Howard isomorphism}.
\citet{curry_1934} observed that every type of a~function, $S \to T$,
can be read as a~proposition of an~implication, $S \supset T$. Then there exists
a~function of a~given type if and only if, the~corresponding proposition is
provable. \citet{curry_1958} later extended the~observation to also include
the~correspondence between terms and proofs. Finally, in 1969, in manuscript not
published until much later, \citet{howard_1980} described the~relation between
the~natural deduction and the~simply typed \lc, as well as shown that
the~simplification of proofs corresponds to the~evaluation of programs.
\citet{wadler_2015} provides a~detailed yet approachable introduction to
the~topic. Now we will generalise the~simple types into their dependent
counterparts and use the~Curry–Howard correspondence to form a~better intuition
around them.

The~dependent analogue of the~type $S \to T$ is the~\emph{dependent
function type}, in the~academic literature usually written as ${(\Pi x \is{}
S \, . \: T(x))}$, but we will write:
\[
  \dep x S {T(x)}.
\]
Here, $S$ is a~type, but \,$T(x)$ is a~function whose argument is of type $S$
and it produces value that is a~type. Thus, a~term of type $\dep x S {T(x)}$
represents function that for an~argument $N$ of type $S$ produces a~value of
type \,$T(N)$. In the~special case that \,$T(x)$ is a~constant function whose
value is always the~type $U$, $\dep x S {T(x)}$ is the~type $S \to U$.

On the~logic side, the~dependent function type corresponds to a~universal
quantification; hence, we can read it as ``for all $x$ in $S$, $T(x)$.''
The~$\Pi$ in the~notation of the~dependent function type references the~fact
that we can interpret it as a~\emph{product} of \,$T(x)$, for every $x \in S$;
that is, a~value of type $\dep x S {T(x)}$ can be interpreted as a~tuple of size
$|S|$, where the~$x$th element is of type \,$T(x)$.

The~dependent analogue of type $S \times T$ is the~\emph{dependent pair type},
again, usually written as ${(\Sigma x \is{} S \, . \: T(x))}$, but we will
write:
\[
  (x \is{} S) \times T(x).
\]
The value of this type is a~pair $\mpair x y$, where $x$ is of type $S$ and $y$
is of type $T(x)$; hence, the~type of the~second element is determined by
the~value of the~first.

This type corresponds to the~existential quantification in logic. It uses $S$ in
its notation because we can interpret it as a~\emph{disjoint union} of all
$T(x)$, with an~index from $S$; meaning, a~value of type $(x \is{} S) \times
T(x)$ can be interpreted as a~member of the~set
\[
  \bigcup_{x \in S} \{ \mpair x y \mid y \in T(x) \}.
\]
By having a~value of this dependent pair type, we are therefore \emph{proving}
that ``there exists an~$x \in S$, such that $T(x)$ is inhabited,'' where
\emph{inhabited} means that the~type contains some value.

In dependent types, terms can occur in place of types so we must scrap
the~distinction between terms and types. Thus, we will define
\emph{pseudo-terms} which will subsume both the~terms from \autoref{def:stlc}
and types.

Now that types will be just a~special kind of terms, we will change the~notation
of the~typed λ-abstraction; we will write
\[
  \lam {x \is{} T} M,
\]
instead of $\lam {x^T} M$, analogously to the~way we write the~dependent
function type.

\sectionwithtoc{Pseudo-terms}

For the~following type systems, we will use the~general notion of
\emph{pseudo-terms}. First, we define a~generous \emph{pseudo-terms} grammar and
then we will construct typing rules, that identify the~well-typed terms within
pseudo-terms.

\begin{definition}\label{def:pseudo-term}
  The~set of all \emph{pseudo-terms} is defined inductively as follows:
  \begin{enumerate} %TODO: Get rid of enumerate, rewrite in mathpar like QTT?
    \item every variable is a~pseudo-term;
    \item every atomic type is a~pseudo-term;
    \item if $x$ is a~variable, and $M$ and $N$ are pseudo-terms, then
      $(\lam {x \is{} M} N)$ is a~pseudo-term.
    \item if $M$ and $N$ are pseudo-terms, then $(M \: N)$ is a~pseudo-term;
    \item if $M$ and $N$ are pseudo-terms and $x$ is a~variable which does not
      occur free in $M$, then $\dep x M N$ is a~pseudo-term.
    \item if $M$ and $N$ are pseudo-terms, then $\mpair M N$ is a~pseudo-term.
    \item if $x, y$ are variables and $M$ and $N$ are pseudo-terms, then
      $\textrm{let} \: \mpair x y = M \: \textrm{in} \: N$ is a~pseudo-term.
    \item if $M$ and $N$ are pseudo-terms and $x$ is a~variable which does not
      occur free in $M$, then $(x \is{} M) \times N$ is a~pseudo-term.
  \end{enumerate}
\end{definition}

The~reduction on pseudo-terms is defined by replacing the~$\beta$-reduction on
pure \lts with one of the~form: \todo{[WHAT ABOUT PAIRS?]}
\[
  (\lam {x \is{} S} M) \: N \triangleright [N/x]M.
\]

Consider the~possible choices of the~set of atomic types of a~given system.
First, there are all the~familiar types, like the~type of integers $\Int$, or
the~type of Boolean values $\Bool$. These depend on the~domain of the~type
system and they are not theoretically interesting. Conversely, the~second kind
of atomic types is crucial to the~properties of the~type system; these types are
called \emph{sorts}. Our type systems will use only one sort, \univ, called
\emph{Universe}. It represents the~type of types. We will also have the~axiom
\begin{mathpar}
  \inferrule*
  { }
  {\vdash \univ \is{} \univ},
\end{mathpar}
which states that the~type of types is itself a~type. The~choice of a~single
sort lets us simplify the~implementation of our type system, but it also has
some downsides; when interpreted under the~Curry–Howard correspondence, the~type
system yields an~inconsistent logic, which is a~logic that lets us derive
a~contraction. This, in the~type-theoretic terms, means that every type is
inhabited.

For a~type system to correspond to a~consistent logic, we would have to have at
least two sorts~\citep{hurkens_1995}. \citet{barendregt_1993} introduced a~group
of eight typing systems, which are known as the~\emph{λ-cube} due to their
mutual relationships. All these systems have used the~sorts $\star$ and
$\square$, related by the~rule
\begin{mathpar}
  \inferrule*
  { }
  {\vdash \star \is{} \square}.
\end{mathpar}
This forms a~type system with the~expressive power of a~second-order
logic~\todo{[TRUE?]}. Another option is to have an~infinite sequence of sorts
$\star_0, \star_1, \dots$, related with the~rule
\begin{mathpar}
  \inferrule*
  { }
  {\vdash \star_i \is{} \star_{i+1}}.
\end{mathpar}
This gives rise to a~type system with the~expressive power of a~higher-order
logic.

\sectionwithtoc{Pseudo-contexts}

With dependent types in mind, we need to revisit the~semantics of the~judgment
$\Gamma \vdash M \is{} S$. In typing systems, the~list of assumptions $\Gamma$,
henceforth called \emph{context}, contains only type assignments. We, however,
need to make sure that these assignments are well-formed; that is, for every
$x \is{} S$ in $\Gamma$, we want to make sure that $S$ is a~proper type. For
example, we want to reject the~list
\[
  a \is{} \univ, \; f \is{} \dep x b a,
\]
because we do not know the~type of the~variable $b$. A~valid context would be:
\[
  a \is{} \univ, \; b \is{} \univ, \; f \is{} \dep x b a.
\]
Hence, we first define \emph{pseudo-contexts} and then identify the~contexts
within.

\begin{definition}
  A~\emph{pseudo-context} is a~sequence of formulas of the~form
  \[
    x_1 \is{} S_1, \dotsc , x_n \is{} S_n,
  \]
  where $x_1, \dotsc , x_n$ are distinct variables and $S_1, \dotsc, S_n$ are
  pseudo-terms.
\end{definition}

Empty pseudo-context is denoted by $\diamond$, or it is omitted when no
confusion is likely.

\sectionwithtoc{Dependently typed \lc}\label{sec:dtlc}

Using  pseudo-contexts and pseudo-terms, we are able to define a~type-assignment
system, that assigns the~dependent types, and is thus more expressive then
the~simply typed \lc, since we can model the~simple type $S \to T$ by defining
it as $\dep x S T$, where $x \notin \fv T$.

The~increased expressiveness of dependent types lies in the~ability to quantify
over \univ. We will see an~example of this after we formalise the~type judgment
rules.

The~rules that identify contexts within pseudo-contexts and terms within
pseudo-terms are mutually recursive. Contexts are identified by the~judgment
$\Gamma \vdash$, defined by the~following rules:
\begin{mathpar}
  \inferrule*
  { }
  {\diamond \vdash}

  \inferrule*
  {\Gamma \vdash \\ \Gamma \vdash S : \univ}
  {\Gamma, x \is{} S \vdash}
\end{mathpar}
and terms are identified by the~judgment $\Gamma \vdash M \is{} S$, defined by
rules:
\begin{mathpar}
  \inferrule*[right=Fun]
  {\Gamma \vdash S \is{} \univ \\ \Gamma, x \is{} S \vdash T \is{} \univ}
  {\Gamma \vdash \dep x S T \is{} \univ}

  \inferrule*[right=App$'$]
  {
    \Gamma \vdash M \is{} \dep x S T \\
    \Gamma \vdash N \is{} S \\
  }
  {\Gamma \vdash M \: N \is{} [N/x]T}

  \inferrule*[right=Lam$'$]
  {
    \Gamma, x \is{} S \vdash M \is{} T \\
    \Gamma \vdash \dep x S T \is{} \univ
  }
  {\Gamma \vdash (\lam {x \is{} S} M) \is{} \dep x S T}
\end{mathpar}

Now we can look at an~example of quantification over \univ. For example,
although
\begin{equation}\label{eq:pi_type}
  s \is{} \univ \vdash \dep x s s \is{} \univ
\end{equation}
and
\begin{equation}\label{eq:id_lam}
  s \is{} \univ \vdash (\lam {x \is{} s} x) \is{} \dep x s s
\end{equation}
can be expressed with just simple types, to be able to successfully derive
the~type of an~identity function that works for any type, we need dependent
function types. Meaning, we can combine judgments (\ref{eq:pi_type}) and
(\ref{eq:id_lam}) and deduce:
\begin{mathpar}
  \inferrule*[right=Lam$'$]
  {
    \text{(\ref{eq:id_lam})} \\
    \inferrule*[right=Fun]
    {
      \inferrule*
      { }
      {\vdash \univ \is{} \univ} \\
      \text{(\ref{eq:pi_type})}
    }
    {\vdash \dep s \univ {\dep x s s} \is{} \univ}
  }
  {
    \vdash (\lam {s \is{} \univ} {\lam {x \is{} s} x}) \is{}
      \dep s \univ {\dep x s s}
  }.
\end{mathpar}

Now $\lam {x \is{} s} x$ is the~identity function on type $s$. Hence
\[
  \lam {s \is{} \univ} {\lam {x \is{} s} x}
\]
is a~function which, when applied to any type of type \univ, gives the~identity
function over that type.

